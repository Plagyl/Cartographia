<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cartographie SI avec Simulation de Cybercrise</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <style>
        body {
            margin: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #0a0a0a;
            color: #fff;
            overflow: hidden; 
        }

        #container {
            width: 100vw;
            height: 100vh;
            position: relative;
            display: flex;
        }

        #network {
            flex: 1;
            height: 100%;
        }

        .node {
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .node:hover {
            stroke-width: 3px;
            filter: brightness(1.2);
        }

        .node.compromised {
            animation: pulse 2s infinite;
            stroke: #ff0040;
            stroke-width: 4px;
        }

        .node.parent-node {
            opacity: 0.7;
            stroke-dasharray: 5,5;
        }

        @keyframes pulse {
            0% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.7; transform: scale(1.1); }
            100% { opacity: 1; transform: scale(1); }
        }

        .attack-path {
            stroke: #ff0040;
            stroke-width: 3px;
            stroke-opacity: 0.8;
            stroke-dasharray: 5,5;
            animation: dash 2s linear infinite;
        }

        @keyframes dash {
            to {
                stroke-dashoffset: -10;
            }
        }

        .node-label {
            font-size: 12px;
            fill: #fff;
            text-anchor: middle;
            pointer-events: none;
            text-shadow: 0 0 4px rgba(0,0,0,0.9);
            font-weight: 500;
        }

        .link {
            stroke: #444;
            stroke-opacity: 0.6;
            transition: all 0.3s ease;
        }

        .link.parent-link {
            stroke-opacity: 0.3;
        }

        .link:hover {
            stroke-opacity: 1;
            stroke-width: 2px;
        }

        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(20, 20, 20, 0.95);
            padding: 20px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            max-width: 350px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
            max-height: calc(100vh - 40px); 
            overflow-y: auto; 
        }

        #attack-trace {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(20, 20, 20, 0.95);
            padding: 20px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 0, 64, 0.3);
            width: 300px;
            max-height: calc(100vh - 40px); 
            overflow-y: auto;
            box-shadow: 0 4px 20px rgba(255,0,64,0.2);
            display: none;
        }

        #attack-trace.active {
            display: block;
        }

        #attack-trace h4 {
            margin-top: 0;
            color: #ff0040;
            border-bottom: 1px solid rgba(255,0,64,0.3);
            padding-bottom: 10px;
        }

        .attack-chain-item {
            background: rgba(255,0,64,0.1);
            border: 1px solid rgba(255,0,64,0.3);
            border-radius: 5px;
            padding: 10px;
            margin-bottom: 10px;
            font-size: 13px;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
        }

        .attack-chain-item:hover {
            background: rgba(255,0,64,0.2);
            border-color: rgba(255,0,64,0.5);
            transform: translateX(-5px);
            box-shadow: 0 2px 10px rgba(255,0,64,0.3);
        }

        .attack-chain-item::after {
            content: "→";
            position: absolute;
            right: 15px;
            top: 50%;
            transform: translateY(-50%);
            color: #ff0040;
            font-size: 18px;
            opacity: 0;
            transition: opacity 0.2s;
        }

        .attack-chain-item:hover::after {
            opacity: 1;
        }

        .attack-chain-item .timestamp {
            color: #ff6b6b;
            font-size: 11px;
            margin-bottom: 5px;
        }

        .attack-chain-item .node-info {
            color: #fff;
            margin-bottom: 3px;
        }

        /* MODIFIED: Style for node path in attack chain */
        .attack-chain-item .node-path-info {
            color: #bbb;
            font-size: 11px;
            margin-bottom: 3px;
            word-break: break-all; /* Ensure long paths wrap */
        }

        .attack-chain-item .impact {
            color: #ffa500;
            font-size: 12px;
            margin-top: 5px;
        }

        #breadcrumb {
            margin-bottom: 15px;
            padding: 10px;
            background: rgba(40, 40, 40, 0.5);
            border-radius: 5px;
            font-size: 14px;
        }

        .breadcrumb-item {
            display: inline-block;
            color: #4a9eff;
            cursor: pointer;
            transition: color 0.2s;
        }

        .breadcrumb-item:hover {
            color: #6bb6ff;
            text-decoration: underline;
        }

        .breadcrumb-separator {
            margin: 0 8px;
            color: #666;
        }

        #info {
            margin-top: 15px;
            padding: 10px;
            background: rgba(40, 40, 40, 0.5);
            border-radius: 5px;
            font-size: 13px;
        }

        .stat {
            margin: 5px 0;
            display: flex;
            justify-content: space-between;
        }

        .stat-label {
            color: #999;
        }

        .stat-value {
            color: #4a9eff;
            font-weight: bold;
        }

        .stat-value.alert {
            color: #ff0040;
        }

        button {
            background: #4a9eff;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            margin: 5px 5px 5px 0;
            font-size: 14px;
            transition: all 0.2s;
        }

        button:hover {
            background: #6bb6ff;
            transform: translateY(-1px);
        }

        button:disabled { 
            background: #555;
            color: #999;
            cursor: not-allowed;
            transform: none;
        }

        button.danger {
            background: #ff0040;
        }

        button.danger:hover:not(:disabled) { 
            background: #ff3366;
        }

        button.back {
            background: #666;
        }

        button.back:hover {
            background: #888;
        }

        #crisis-info {
            margin-top: 15px;
            padding: 10px;
            background: rgba(255, 0, 64, 0.1);
            border: 1px solid #ff0040;
            border-radius: 5px;
            display: none;
        }

        #crisis-info.active {
            display: block;
        }

        .crisis-stat {
            color: #ff6b6b;
            margin: 5px 0;
        }

        #tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.95);
            padding: 12px;
            border-radius: 5px;
            font-size: 12px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            border: 1px solid rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(5px);
            max-width: 300px; 
            word-wrap: break-word; 
        }

        #attack-trace::-webkit-scrollbar, #controls::-webkit-scrollbar { 
            width: 8px;
        }

        #attack-trace::-webkit-scrollbar-track, #controls::-webkit-scrollbar-track { 
            background: rgba(40,40,40,0.3);
            border-radius: 4px;
        }
        #attack-trace::-webkit-scrollbar-thumb {
             background: rgba(255,0,64,0.5);
             border-radius: 4px;
        }
        #controls::-webkit-scrollbar-thumb { 
             background: rgba(100,100,100,0.5);
             border-radius: 4px;
        }

        #attack-trace::-webkit-scrollbar-thumb:hover { 
            background: rgba(255,0,64,0.7);
        }
        #controls::-webkit-scrollbar-thumb:hover { 
            background: rgba(120,120,120,0.7);
        }


        .speed-control {
            margin-top: 10px;
            padding: 10px;
            background: rgba(40, 40, 40, 0.5);
            border-radius: 5px;
        }

        .speed-slider {
            width: 100%;
            height: 5px;
            border-radius: 5px;
            background: rgba(255,0,64,0.2);
            outline: none;
            -webkit-appearance: none;
        }

        .speed-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 15px;
            height: 15px;
            border-radius: 50%;
            background: #ff0040;
            cursor: pointer;
        }

        .speed-slider::-moz-range-thumb {
            width: 15px;
            height: 15px;
            border-radius: 50%;
            background: #ff0040;
            cursor: pointer;
            border: none;
        }

        .speed-label {
            display: flex;
            justify-content: space-between;
            font-size: 12px;
            color: #999;
            margin-bottom: 5px;
        }
    </style>
</head>
<body>
    <div id="container">
        <svg id="network"></svg>
        
        <div id="controls">
            <h3 style="margin-top: 0; margin-bottom: 15px;">Cartographie SI</h3>
            
            <div id="breadcrumb">
                <span class="breadcrumb-item" onclick="navigateToRoot()">Groupe</span>
            </div>
            
            <div id="info">
                <div class="stat">
                    <span class="stat-label">Nœuds visibles:</span>
                    <span class="stat-value" id="visible-nodes">0</span>
                </div>
                <div class="stat">
                    <span class="stat-label">Niveau actuel:</span>
                    <span class="stat-value" id="current-level">0</span>
                </div>
                <div class="stat">
                    <span class="stat-label">Total infrastructure:</span>
                    <span class="stat-value">100,000+ assets</span>
                </div>
                <div class="stat">
                    <span class="stat-label">Assets compromis:</span>
                    <span class="stat-value alert" id="compromised-nodes">0</span>
                </div>
            </div>

            <div id="crisis-info">
                <h4 style="margin-top: 0; color: #ff0040;">🚨 Cybercrise Active</h4>
                <div class="crisis-stat">Type d'attaque: <strong id="attack-type">-</strong></div>
                <div class="crisis-stat">Vecteur initial: <strong id="attack-vector">-</strong></div>
                <div class="crisis-stat">Niveau de sévérité: <strong id="severity">-</strong></div>
                <div class="crisis-stat">Temps écoulé: <strong id="crisis-time">0s</strong></div>
                <div class="speed-control">
                    <div class="speed-label">
                        <span>Vitesse de propagation</span>
                        <span id="speed-value">2.0s</span>
                    </div>
                    <input type="range" class="speed-slider" id="speed-slider" min="500" max="15000" value="2000" step="100">
                </div>
            </div>
            
            <button class="back" onclick="navigateBack()">← Retour</button>
            <button onclick="resetZoom()">Réinitialiser Zoom</button>
            <button onclick="toggleGraphAnimation()">Pause Animation Graphe</button> 
            <button class="danger" onclick="simulateCrisis()">🔥 Simuler Cybercrise</button>
            <button id="toggle-crisis-pause-button" onclick="toggleCrisisPause()" disabled>⏸️ Pause Crise</button>
            <button onclick="clearCrisis()">Nettoyer Crise</button>
        </div>

        <div id="attack-trace">
            <h4>🔍 Chaîne d'Attaque</h4>
            <div id="attack-chain"></div>
        </div>
        
        <div id="tooltip"></div>
    </div>

    <script>
        // Configuration
        // const width = window.innerWidth; // Not strictly needed here as SVG container size is used
        // const height = window.innerHeight; // Not strictly needed here
        let currentViewNode = null; 
        let parentOfViewNode = null; 
        let navigationHistory = [];
        let graphSimulation; 
        let isGraphAnimating = true; 
        
        let crisisActive = false;
        let compromisedNodes = new Set();
        let attackChain = [];
        let crisisInterval;
        let crisisStartTime;
        let nodePositions = new Map();
        let propagationSpeed = 2000; 

        let isCrisisPaused = false;
        let crisisPauseStartTime;
        let crisisTotalPausedTime = 0;

        const toggleCrisisPauseButton = document.getElementById('toggle-crisis-pause-button');


        // Types d'infrastructure SI
        const infrastructureTypes = {
            0: { 
                names: ["SA 1", "SA 2", "SA 3", "SA 4", "SA 5", "SA 6", "SA 7", "SA 8"],
                type: "site",
                color: "#ff6b6b"
            },
            1: { 
                names: ["DMZ", "LAN Corporate", "Datacenter", "Zone Admin", "Zone Dev", "Zone Prod", "WiFi Guest", "VPN", "Cloud AWS", "Cloud Azure", "Backup Site", "DR Site"],
                type: "zone",
                color: "#4a9eff"
            },
            2: { 
                names: ["Services Web", "Base de Données", "Messagerie", "Active Directory", "Pare-feu", "Load Balancer", "Monitoring", "Backup", "Antivirus", "SIEM", "Proxy", "DNS", "DHCP", "File Server", "Print Server"],
                type: "service",
                color: "#51cf66"
            },
            3: { 
                names: ["SRV-WEB", "SRV-DB", "SRV-APP", "SRV-MAIL", "FW", "RTR", "SW", "SRV-FILE", "SRV-PRINT", "SRV-BACKUP", "VM", "CONTAINER", "SRV-LOG", "SRV-MON", "NAS"],
                type: "server",
                color: "#ffd93d"
            },
            4: { 
                names: ["Apache", "Nginx", "MySQL", "PostgreSQL", "Exchange", "Outlook", "SharePoint", "SAP", "CRM", "ERP", "Jenkins", "GitLab", "Docker", "Kubernetes", "Elasticsearch"],
                type: "application",
                color: "#ff9ff3"
            }
        };

        // Types d'attaques avec vecteurs
        const attackTypes = [
            { 
                name: "Ransomware", 
                severity: "Critique", 
                spread: 0.7,
                vector: "Email de phishing",
                impacts: ["Chiffrement des données", "Interruption de service", "Demande de rançon"]
            },
            { 
                name: "DDoS Distribué", 
                severity: "Élevée", 
                spread: 0.5,
                vector: "Botnet externe",
                impacts: ["Saturation réseau", "Indisponibilité services", "Dégradation performances"]
            },
            { 
                name: "APT (Advanced Persistent Threat)", 
                severity: "Critique", 
                spread: 0.8,
                vector: "Compromission supply chain",
                impacts: ["Exfiltration données", "Backdoor installée", "Mouvement latéral"]
            },
            { 
                name: "Malware Polymorphe", 
                severity: "Élevée", 
                spread: 0.6,
                vector: "USB infectée",
                impacts: ["Propagation réseau", "Vol credentials", "Keylogging actif"]
            },
            { 
                name: "Zero-Day Exploit", 
                severity: "Critique", 
                spread: 0.9,
                vector: "Vulnérabilité non patchée",
                impacts: ["Élévation privilèges", "Exécution code arbitraire", "Contournement sécurité"]
            }
        ];

        function generateNetworkData(depth = 0, maxDepth = 5, parentId = null, index = 0, parentType = null) {
            const config = infrastructureTypes[depth] || infrastructureTypes[4];
            let name, id;
            
            if (depth === 0) {
                name = config.names[index % config.names.length];
                id = name.replace(/\s/g, '-');
            } else {
                const baseName = config.names[index % config.names.length];
                const suffix = Math.floor(index / config.names.length);
                name = suffix > 0 ? `${baseName}-${suffix + 1}` : baseName;
                id = parentId ? `${parentId}-${name.replace(/\s/g, '-')}` : name.replace(/\s/g, '-');
            }

            const node = {
                id: id,
                name: name,
                type: config.type,
                depth: depth,
                children: [],
                value: Math.floor(Math.random() * 100) + 1,
                status: Math.random() > 0.05 ? 'active' : 'warning',
                parent: parentId,
                ip: depth > 1 ? generateIP(depth, index) : null,
                criticality: Math.random() > 0.7 ? 'high' : Math.random() > 0.4 ? 'medium' : 'low'
            };

            if (depth < maxDepth - 1) {
                const childCount = depth === 0 ? 8 : depth === 1 ? 12 : depth === 2 ? 10 : depth === 3 ? 8 : 5;
                for (let i = 0; i < childCount; i++) {
                    node.children.push(generateNetworkData(depth + 1, maxDepth, id, i, config.type));
                }
            }
            return node;
        }

        function generateIP(depth, index) {
            const subnet = 10 + depth;
            const host = (index % 254) + 1;
            return `192.168.${subnet}.${host}`;
        }

        const rootData = {
            id: 'root',
            name: 'Groupe Corporate',
            type: 'group',
            depth: -1,
            children: [],
            value: 100,
            status: 'active'
        };

        for (let i = 0; i < 8; i++) {
            rootData.children.push(generateNetworkData(0, 5, 'root', i));
        }

        function getNodeDataForView(node, includeParent = false) { 
            const nodes = [];
            const links = [];
            const viewWidth = document.getElementById('network').clientWidth; 
            const viewHeight = document.getElementById('network').clientHeight; 

            const centerX = viewWidth / 2;
            const centerY = viewHeight / 2;
            const radius = Math.min(viewWidth, viewHeight) * 0.3;
            
            if (includeParent && parentOfViewNode) {
                nodes.push({
                    id: parentOfViewNode.id,
                    name: parentOfViewNode.name,
                    type: parentOfViewNode.type,
                    value: parentOfViewNode.value,
                    status: parentOfViewNode.status,
                    isParent: true,
                    hasChildren: true,
                    compromised: compromisedNodes.has(parentOfViewNode.id),
                    fx: centerX,
                    fy: centerY - radius * 1.5,
                    ip: parentOfViewNode.ip,
                    criticality: parentOfViewNode.criticality
                });
                links.push({
                    source: parentOfViewNode.id,
                    target: node.id,
                    isParentLink: true,
                    value: 10
                });
            }
            
            nodes.push({
                id: node.id,
                name: node.name,
                type: node.type,
                value: node.value,
                status: node.status,
                isCenter: true,
                hasChildren: node.children.length > 0,
                compromised: compromisedNodes.has(node.id),
                fx: centerX,
                fy: centerY,
                ip: node.ip,
                criticality: node.criticality
            });

            const angleStep = node.children.length > 0 ? (2 * Math.PI) / node.children.length : 0;
            node.children.forEach((child, i) => {
                const angle = i * angleStep - Math.PI / 2;
                const x = centerX + radius * Math.cos(angle);
                const y = centerY + radius * Math.sin(angle);
                
                nodes.push({
                    id: child.id,
                    name: child.name,
                    type: child.type,
                    value: child.value,
                    status: child.status,
                    hasChildren: child.children.length > 0,
                    compromised: compromisedNodes.has(child.id),
                    x: nodePositions.has(child.id) ? nodePositions.get(child.id).x : x,
                    y: nodePositions.has(child.id) ? nodePositions.get(child.id).y : y,
                    ip: child.ip,
                    criticality: child.criticality
                });
                links.push({
                    source: node.id,
                    target: child.id,
                    value: Math.random() * 10 + 1,
                    compromised: compromisedNodes.has(node.id) && compromisedNodes.has(child.id)
                });
            });
            return { nodes, links };
        }

        const svg = d3.select('#network');
        const g = svg.append('g');

        const zoom = d3.zoom()
            .scaleExtent([0.1, 4])
            .on('zoom', (event) => {
                g.attr('transform', event.transform);
            });
        svg.call(zoom);

        function displayLevel(nodeData, keepParent = false) {
            currentViewNode = nodeData;
            const data = getNodeDataForView(nodeData, keepParent && parentOfViewNode !== null); 
            
            g.selectAll('.node-group').each(function(d) {
                if (d.x && d.y) {
                    nodePositions.set(d.id, { x: d.x, y: d.y });
                }
            });
            
            g.selectAll('*').remove();
            d3.select('#visible-nodes').text(data.nodes.length);
            d3.select('#current-level').text(Math.max(0, nodeData.depth));
            updateCompromisedCount();

            const viewWidth = document.getElementById('network').clientWidth; 
            const viewHeight = document.getElementById('network').clientHeight; 

            graphSimulation = d3.forceSimulation(data.nodes) 
                .force('link', d3.forceLink(data.links).id(d => d.id).distance(d => d.isParentLink ? 200 : 150).strength(0.5))
                .force('charge', d3.forceManyBody().strength(d => d.isParent ? -500 : -300))
                .force('collision', d3.forceCollide().radius(d => d.isCenter ? 50 : d.isParent ? 40 : 30).strength(0.7))
                .force('x', d3.forceX(d => d.fx || viewWidth / 2).strength(0.1)) 
                .force('y', d3.forceY(d => d.fy || viewHeight / 2).strength(0.1)) 
                .alphaDecay(0.02);

            const link = g.append('g')
                .selectAll('line')
                .data(data.links)
                .join('line')
                .attr('class', d => `link ${d.isParentLink ? 'parent-link' : ''} ${d.compromised ? 'attack-path' : ''}`)
                .attr('stroke-width', d => Math.sqrt(d.value));

            const nodeGroup = g.append('g')
                .selectAll('g')
                .data(data.nodes)
                .join('g')
                .attr('class', 'node-group')
                .attr('id', d => d.id)
                .call(drag(graphSimulation)); 

            nodeGroup.append('circle')
                .attr('class', d => `node ${d.compromised ? 'compromised' : ''} ${d.isParent ? 'parent-node' : ''}`)
                .attr('r', d => d.isCenter ? 35 : d.isParent ? 30 : 25)
                .attr('fill', d => {
                    if (d.compromised) return '#ff0040';
                    const typeConfig = Object.values(infrastructureTypes).find(t => t.type === d.type);
                    return typeConfig ? typeConfig.color : '#4a9eff';
                })
                .attr('stroke', '#fff')
                .attr('stroke-width', 2)
                .attr('opacity', d => d.status === 'active' ? 1 : 0.6)
                .on('click', function(event, d) {
                    if (d.hasChildren && !d.isParent) {
                        const clickedNodeData = findNodeById(rootData, d.id);
                        if (clickedNodeData) {
                            if (!d.isCenter) {
                                parentOfViewNode = currentViewNode; 
                            }
                            navigationHistory.push(currentViewNode); 
                            updateBreadcrumb();
                            displayLevel(clickedNodeData, true);
                        }
                    } else if (d.isParent) {
                        navigateBack();
                    }
                })
                .on('mouseover', function(event, d) {
                    const tooltip = d3.select('#tooltip');
                    let statusText = d.compromised ? '<span style="color: #ff0040;">COMPROMIS</span>' : d.status;
                    let ipText = d.ip ? `<br>IP: ${d.ip}` : '';
                    let criticalityText = d.criticality ? `<br>Criticité: ${d.criticality}` : '';
                    let fullPath = getNodePathString(d.id); 

                    tooltip.html(`
                        <strong>${d.name}</strong><br>
                        Type: ${d.type}${ipText}${criticalityText}<br>
                        Chemin: ${fullPath}<br> 
                        Status: ${statusText}<br>
                        ${d.isParent ? 'Cliquez pour revenir' : d.hasChildren ? 'Cliquez pour explorer' : 'Asset terminal'}
                    `)
                    .style('opacity', 1)
                    .style('left', (event.pageX + 10) + 'px')
                    .style('top', (event.pageY - 10) + 'px');
                })
                .on('mouseout', function() {
                    d3.select('#tooltip').style('opacity', 0);
                });

            nodeGroup.append('text')
                .attr('class', 'node-label')
                .attr('dy', 4)
                .text(d => d.name.length > 20 ? d.name.substring(0, 17) + '...' : d.name);

            graphSimulation.on('tick', () => { 
                link
                    .attr('x1', d => d.source.x)
                    .attr('y1', d => d.source.y)
                    .attr('x2', d => d.target.x)
                    .attr('y2', d => d.target.y);
                nodeGroup.attr('transform', d => `translate(${d.x},${d.y})`);
            });
            if (!isGraphAnimating) graphSimulation.stop(); 
        }

        function drag(sim) { 
            function dragstarted(event) {
                if (!event.active) sim.alphaTarget(0.3).restart();
                event.subject.fx = event.subject.x;
                event.subject.fy = event.subject.y;
            }
            function dragged(event) {
                event.subject.fx = event.x;
                event.subject.fy = event.y;
            }
            function dragended(event) {
                if (!event.active) sim.alphaTarget(0);
                if (!event.subject.isCenter && !event.subject.isParent) {
                    event.subject.fx = null;
                    event.subject.fy = null;
                }
            }
            return d3.drag()
                .on('start', dragstarted)
                .on('drag', dragged)
                .on('end', dragended);
        }

        function findNodeById(node, id) {
            if (node.id === id) return node;
            for (let child of node.children) {
                const found = findNodeById(child, id);
                if (found) return found;
            }
            return null;
        }

        function getNodePathString(nodeId) {
            let path = [];
            let currNode = findNodeById(rootData, nodeId);
            while (currNode && currNode.id !== 'root') {
                path.unshift(currNode.name);
                if (currNode.parent) {
                    currNode = findNodeById(rootData, currNode.parent);
                } else {
                    currNode = null; 
                }
            }
            path.unshift(rootData.name); 
            return path.join(' / ');
        }


        function navigateToRoot() {
            navigationHistory = [];
            parentOfViewNode = null; 
            nodePositions.clear();
            updateBreadcrumb();
            displayLevel(rootData);
        }

        function navigateBack() {
            if (navigationHistory.length > 0) {
                const previousNodeData = navigationHistory.pop();
                parentOfViewNode = navigationHistory.length > 0 ? navigationHistory[navigationHistory.length - 1] : null; 
                updateBreadcrumb();
                displayLevel(previousNodeData, parentOfViewNode !== null); 
            }
        }

        function navigateToNode(nodeId) { 
            const targetNodeData = findNodeById(rootData, nodeId);
            if (targetNodeData) {
                const tempHistory = [];
                let currentAncestor = targetNodeData;
                while (currentAncestor && currentAncestor.parent) {
                    const parent = findNodeById(rootData, currentAncestor.parent);
                    if (parent && parent.id !== 'root') {
                        tempHistory.unshift(parent);
                    }
                    currentAncestor = parent;
                }
                navigationHistory = tempHistory;
                parentOfViewNode = navigationHistory.length > 0 ? navigationHistory[navigationHistory.length - 1] : null; 
                updateBreadcrumb();
                displayLevel(targetNodeData, parentOfViewNode !== null); 
            }
        }
        
        function navigateToSpecificNode(nodeId) { 
            const targetNodeData = findNodeById(rootData, nodeId);
            if (!targetNodeData) return;
            
            const path = [];
            let current = targetNodeData;
            while (current && current.id !== 'root') {
                path.unshift(current);
                const parent = findNodeById(rootData, current.parent); 
                current = parent;
            }
            
            navigationHistory = [];
            parentOfViewNode = null; 
            
            for (let i = 0; i < path.length - 1; i++) {
                navigationHistory.push(path[i]);
            }
            
            if (navigationHistory.length > 0) {
                parentOfViewNode = navigationHistory[navigationHistory.length - 1]; 
            }
            
            updateBreadcrumb();
            displayLevel(targetNodeData, parentOfViewNode !== null); 
            
            setTimeout(() => {
                const targetElement = d3.selectAll('.node-group').filter(d => d.id === nodeId);
                if (!targetElement.empty()) {
                    targetElement.select('circle')
                        .transition().duration(300).attr('r', 40)
                        .transition().duration(300).attr('r', d => d.isCenter ? 35 : d.isParent ? 30 : 25);
                }
            }, 500);
        }

        function updateBreadcrumb() {
            const breadcrumb = d3.select('#breadcrumb');
            breadcrumb.html('<span class="breadcrumb-item" onclick="navigateToRoot()">Groupe</span>');
            
            navigationHistory.forEach((node) => { 
                breadcrumb.append('span').attr('class', 'breadcrumb-separator').text('>');
                breadcrumb.append('span')
                    .attr('class', 'breadcrumb-item')
                    .text(node.name)
                    .on('click', () => navigateToNode(node.id));
            });

            if (currentViewNode && currentViewNode.id !== 'root') { 
                breadcrumb.append('span').attr('class', 'breadcrumb-separator').text('>');
                breadcrumb.append('span').style('color', '#fff').text(currentViewNode.name); 
            }
        }

        let currentAttack = null;
        
        function simulateCrisis() {
            if (crisisActive) return;
            
            crisisActive = true;
            isCrisisPaused = false; 
            crisisTotalPausedTime = 0; 
            toggleCrisisPauseButton.disabled = false; 
            toggleCrisisPauseButton.textContent = '⏸️ Pause Crise'; 

            compromisedNodes.clear();
            attackChain = [];
            crisisStartTime = Date.now();
            
            currentAttack = attackTypes[Math.floor(Math.random() * attackTypes.length)];
            
            d3.select('#crisis-info').classed('active', true);
            d3.select('#attack-type').text(currentAttack.name);
            d3.select('#attack-vector').text(currentAttack.vector);
            d3.select('#severity').text(currentAttack.severity);
            d3.select('#attack-trace').classed('active', true);
            
            const initialTarget = selectInitialTarget();
            if (initialTarget) {
                compromiseNode(initialTarget, "Point d'entrée initial");
            }
            
            startPropagation();
            displayLevel(currentViewNode, parentOfViewNode !== null); 
        }

        function toggleCrisisPause() {
            if (!crisisActive) return;

            isCrisisPaused = !isCrisisPaused;
            if (isCrisisPaused) {
                clearInterval(crisisInterval);
                crisisPauseStartTime = Date.now();
                toggleCrisisPauseButton.textContent = '▶️ Reprendre Crise';
            } else {
                crisisTotalPausedTime += Date.now() - crisisPauseStartTime;
                startPropagation();
                toggleCrisisPauseButton.textContent = '⏸️ Pause Crise';
            }
        }


        function startPropagation() {
            if (crisisInterval) clearInterval(crisisInterval);
            if (isCrisisPaused || !crisisActive) return; 

            crisisInterval = setInterval(() => {
                if (isCrisisPaused) return; 
                spreadAttack(currentAttack.spread);
                updateCrisisTime();
                displayLevel(currentViewNode, parentOfViewNode !== null); 
            }, propagationSpeed);
        }

        function selectInitialTarget() {
            const vulnerableNodes = [];
            function findVulnerable(node) {
                if (node.depth >=2 && (node.status === 'warning' || node.criticality === 'low')) { 
                    vulnerableNodes.push(node);
                }
                node.children.forEach(child => findVulnerable(child));
            }
            findVulnerable(rootData);
            if (vulnerableNodes.length > 0) {
                return vulnerableNodes[Math.floor(Math.random() * vulnerableNodes.length)];
            } else { 
                let allDeepNodes = [];
                function collectDeepNodes(node) {
                    if (node.depth >=2) allDeepNodes.push(node);
                    node.children.forEach(collectDeepNodes);
                }
                collectDeepNodes(rootData);
                return allDeepNodes.length > 0 ? allDeepNodes[Math.floor(Math.random() * allDeepNodes.length)] : (rootData.children[0]?.children[0]?.children[0] || rootData);
            }
        }

        function compromiseNode(node, reason) {
            if (!node || compromisedNodes.has(node.id)) return;
            compromisedNodes.add(node.id);
            const timestamp = new Date().toLocaleTimeString('fr-FR', { hour: '2-digit', minute: '2-digit', second: '2-digit' });
            const impact = currentAttack.impacts[Math.floor(Math.random() * currentAttack.impacts.length)];
            attackChain.push({ timestamp, node, reason, impact });
            updateAttackChain();
        }

        function spreadAttack(spreadRate) {
            const nodesToCompromise = [];
            compromisedNodes.forEach(nodeId => {
                const node = findNodeById(rootData, nodeId);
                if (node) {
                    node.children.forEach(child => {
                        if (!compromisedNodes.has(child.id) && Math.random() < spreadRate) {
                            nodesToCompromise.push({ node: child, reason: `Propagation depuis ${node.name}` });
                        }
                    });
                    if (node.parent && !compromisedNodes.has(node.parent) && Math.random() < spreadRate * 0.3) {
                        const parentNodeObj = findNodeById(rootData, node.parent);
                        if (parentNodeObj && parentNodeObj.id !== 'root') { 
                             nodesToCompromise.push({ node: parentNodeObj, reason: `Mouvement latéral vers ${parentNodeObj.name}` });
                        }
                    }
                }
            });
            nodesToCompromise.forEach(item => compromiseNode(item.node, item.reason));
        }

        function updateAttackChain() {
            const chainContainer = d3.select('#attack-chain');
            chainContainer.selectAll('.attack-chain-item')
                .data(attackChain.slice().reverse())
                .join('div')
                .attr('class', 'attack-chain-item')
                .attr('data-node-id', d => d.node.id)
                .html(d => { // MODIFIED: Arrow function for cleaner 'this' context if needed, though not used here.
                    const nodePath = getNodePathString(d.node.id); // MODIFIED: Get path string
                    return `
                        <div class="timestamp">${d.timestamp}</div>
                        <div class="node-info"><strong>${d.node.name}</strong> (${d.node.type})</div>
                        <div class="node-path-info">Chemin: ${nodePath}</div> <!-- MODIFIED: Display path -->
                        ${d.node.ip ? `<div class="node-info">IP: ${d.node.ip}</div>` : ''}
                        <div class="node-info">Raison: ${d.reason}</div>
                        <div class="impact">Impact: ${d.impact}</div>
                    `;
                })
                .on('click', (event, d) => navigateToSpecificNode(d.node.id)); 
            
            const chainElement = chainContainer.node();
            if(chainElement) chainElement.scrollTop = 0; 
        }

        function clearCrisis() {
            crisisActive = false;
            isCrisisPaused = false; 
            crisisTotalPausedTime = 0; 
            toggleCrisisPauseButton.disabled = true; 
            toggleCrisisPauseButton.textContent = '⏸️ Pause Crise'; 

            compromisedNodes.clear();
            attackChain = [];
            if (crisisInterval) clearInterval(crisisInterval);
            
            d3.select('#crisis-info').classed('active', false);
            d3.select('#attack-trace').classed('active', false);
            d3.select('#attack-chain').selectAll('*').remove();
            displayLevel(currentViewNode, parentOfViewNode !== null); 
        }

        function updateCompromisedCount() {
            d3.select('#compromised-nodes').text(compromisedNodes.size);
        }

        function updateCrisisTime() {
            if (!crisisActive || isCrisisPaused) return; 
            const elapsed = Math.floor((Date.now() - crisisStartTime - crisisTotalPausedTime) / 1000); 
            d3.select('#crisis-time').text(`${elapsed}s`);
        }

        function resetZoom() {
            svg.transition().duration(750).call(zoom.transform, d3.zoomIdentity);
        }

        function toggleGraphAnimation() { 
            const button = d3.select(event.target); // Standard event object
            if (isGraphAnimating) { 
                if(graphSimulation) graphSimulation.stop(); 
                button.text('Reprendre Animation Graphe');
            } else {
                if(graphSimulation) graphSimulation.alpha(0.3).restart(); 
                button.text('Pause Animation Graphe');
            }
            isGraphAnimating = !isGraphAnimating; 
        }

        window.addEventListener('resize', () => {
            const newWidth = document.getElementById('network').clientWidth; 
            const newHeight = document.getElementById('network').clientHeight; 
            // svg.attr('width', newWidth).attr('height', newHeight); 

            if (graphSimulation) { 
                graphSimulation.force('x', d3.forceX(newWidth / 2).strength(0.1)); 
                graphSimulation.force('y', d3.forceY(newHeight / 2).strength(0.1)); 
                if (isGraphAnimating) graphSimulation.alpha(0.3).restart(); 
            }
        });

        const speedSlider = document.getElementById('speed-slider');
        const speedValueDisplay = document.getElementById('speed-value');
        
        speedSlider.addEventListener('input', function() {
            propagationSpeed = parseInt(this.value);
            speedValueDisplay.textContent = (propagationSpeed / 1000).toFixed(1) + 's';
            if (crisisActive && !isCrisisPaused) { 
                startPropagation();
            }
        });

        navigateToRoot();
        toggleCrisisPauseButton.disabled = true; 
    </script>
</body>
</html>